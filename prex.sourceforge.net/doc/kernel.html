<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Prex Kernel Internals</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <meta name="keywords" content="Prex, embedded, real-time, operating system, RTOS, open source, free">
  <meta name="author" content="Kohsuke Ohtani">
  <link rel="stylesheet" type="text/css" href="../default.css" media="screen">
  <link rel="stylesheet" type="text/css" href="../print.css" media="print">
</head>
<body>

<table id="content" cellpadding="0" cellspacing="0">
  <tbody>

    <tr>
      <td id="header" colspan="2">
        <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr>
          <td id="logo">
            <a href="../index.html">
            <img alt="Prex logo" src="../img/logo.gif" border="0"
            style="width: 250px; height: 54px;"></a>
          </td>
          <td id="brief">
            An Open Source, Royalty-free,<br>
	    Real-time Operating System
          </td>
        </tr>
        </table>
      </td>
    </tr>

    <tr>
      <td colspan="2"><div class="info"><span>
        <a href="../index.html">Prex Home</a> >
        <a href="index.html">Document Index</a> >
        Kernel Internals
      </span></div></td>
    </tr>

  </tbody>
</table>

<div id="doc">

      <h1>Prex Kernel Internals</h1>

<i>For Prex version 0.9.0, 2009/11/20</i>

<h3>Table of Contents</h3>
<ul>
  <li><a href="kernel.html#intro">Introduction</a></li>
  <li><a href="kernel.html#design">Design Philosophies</a></li>
  <li><a href="kernel.html#over">Kernel Overview</a></li>
  <li><a href="kernel.html#task">Task</a></li>
  <li><a href="kernel.html#thread">Thread</a></li>
  <li><a href="kernel.html#sched">Scheduler</a></li>
  <li><a href="kernel.html#memory">Memory Management</a></li>
  <li><a href="kernel.html#ipc">IPC</a></li>
  <li><a href="kernel.html#except">Exception Handling</a></li>
  <li><a href="kernel.html#int">Interrupt Framework</a></li>
  <li><a href="kernel.html#timer">Timer</a></li>
  <li><a href="kernel.html#device">Device I/O Services</a></li>
  <li><a href="kernel.html#sync">Synchronous Services</a></li>
  <li><a href="kernel.html#debug">Debug</a></li>
  <li><a href="kernel.html#hal">Hardware Abstraction Layer</a></li>
</ul>


<h2 id="intro">Introduction</h2>

<p>
This document describes the design and implementation of the Prex kernel.
</p>
<p>
For a full description of the Prex kernel interface,
see the following documents.
</p>
<ul>
  <li><a href="kapi.html">Prex Kernel API reference</a></li>
  <li><a href="hal.html">Hardware Abstraction Layer</a></li>
</ul>

<p>
The following documents may be helpful to understand the security and
power management features of Prex.
</p>
<ul>
  <li><a href="security.html">Prex Platform Security</a></li>
  <li><a href="power.html">Prex Power Management</a></li>
</ul>

<h2 id="design">Design Philosophies</h2>
<p>
The Prex kernel focuses the following points to be designed.
</p>

<h4>Portability</h4>
<p>
Portability is the most important point for the kernel design in Prex.
The Prex kernel is divided into two different layers -
a common kernel layer and a hardware abstraction layer (HAL).

Any routine in the common kernel layer must not access to the H/W by itself.
Instead, it must use the H/W access services provided by HAL.
</p>

<h4>Scalability</h4>
<p>
In order to obtain higher scalability, the kernel does not limit the maximum
number of the kernel objects to create. So, the resources for all kernel
objects are allocated dynamically after system boot.
This can keep the memory prerequisite smaller than the static resource
allocation.
This means that the kernel can create any numbers of threads, objects, devices,
events, mutexes and timers as far as usable memory remains.
</p>
<p>
The kernel supports both of MMU and MMU-less systems. So, most components
of the kernel are designed carefully to work without MMU.
</p>

<h4>Reliability</h4>
<p>
When the remaining memory is exhausted, what should OS do?
If the system can stop with panic() there, we can prevent many error checks
in the kernel.
But obviously, this is not allowed on the reliable system.
Even if the memory is exhausted, a kernel must continue to do its jobs.
So, all kernel codes are always checking the error status returned
by the memory allocation routine.
</p>
<p>
In addition, the kernel must not crush anytime even if any invalid parameter
is passed via kernel API. Basically, the Prex kernel code is written with
"garbage in, error out" principle.
The Prex kernel never stops even if any malicious program is loaded.
</p>

<h4>Interoperability</h4>
<p>
Although the Prex kernel was written from scratch, its applications
will be brought from the other operating systems like BSD. So, the system
call interface is designed with consideration to support generic OS
API like POSIX or APIs for generic RTOS.
</p>
<p>
The error code for the Prex system call is defined as the same name
with POSIX. For example, EINVAL for "Invalid argument", or ENOMEM for
"Out of memory". So, peoples do not have to study new error codes if
they already have skills about POSIX programming.
This is important point to write applications and to read
the kernel code because study of a new error scheme will cause pain
for developers.

In addition, it simplifies the POSIX emulation library because it
does not have to remap the error code.
</p>

<h4>Maintainability</h4>
<p>
All kernel codes are kept clean and simple for the maintenance.
All codes are well-commented and consistent.
It is easy to add or remove new system call into the kernel.
The kernel has the debugging facility like the diagnostic message or
the dump of the kernel objects.
</p>



<h2 id="over">Kernel Overview</h2>

<h3>Kernel Structure</h3>
<p>
The following figure illustrates the Prex kernel components.
</p>

<p class="figure">
<img alt="Kernel Components" src="img/kernel.gif" border="1"
style="width: 547px; height:383px;"><br>
Figure 1. Prex Kernel Components
</p>

<p>
Each kernel object belongs in one of the following groups.
</p>
<ul>
  <li><b>kern</b>: kernel core components</li>
  <li><b>mem</b>: memory managers</li>
  <li><b>ipc</b>: inter process communication</li>
  <li><b>sync</b>: synchronize objects</li>
  <li><b>hal</b>: hardware abstraction layer</li>
</ul>


<p>
These group name are mapped to the directory name of the source tree.
The following figure shows the kernel directory structure of Prex.
</p>

<p class="figure">
<img alt="Kernel Directory" src="img/kdir.gif" border="1"
style="width: 274px; height:313px;"><br>
Figure 2. Kernel Directory Structure
</p>

<h3>Naming Convention</h3>

<p>
The name of "group/object" in figure 1 is mapped to "directory/file" in the
Prex source tree. For example, the thread related functions are located
in "kern/thread.c", and the functions for semaphore are placed
in "sync/sem.c".
</p>

<pre>
/kern/debug.c
/kern/device.c
/kern/exception.c
/kern/irq.c
/kern/sched.c
/kern/system.c
/kern/task.c
/kern/thread.c
/kern/timer.c
/mem/kmem.c
...
</pre>

<p>
In addition, there is a standard naming convention about kernel
routines. The method named <i>bar</i> for the object named <i>foo</i>
should be named "foo_bar". For example, the routine to create a new
thread is named "thread_create", and locking mutex will be "mutex_lock".
This rule is not applied to the name for the local (private) functions
in a file.
</p>



<h3>Features</h3>

<p>
The Prex microkernel provides the following kernel services:
</p>

<ul>
  <li>threads and tasks</li>
  <li>message passing (IPC)</li>
  <li>timers</li>
  <li>exceptions</li>
  <li>device I/O</li>
  <li>mutexes</li>
  <li>semaphores</li>
  <li>condition variables</li>
  <li>debug and log service</li>
</ul>



<h2 id="task">Task</h2>

<h3>Major Concepts</h3>

<p>
Prex tasks contain the capabilities, IPC objects, synchronize objects, and address space of
a running entity. Tasks perform no computation; they are a framework for running threads.
</p>
<p>
The following figure illustrates contents of the task.
</p>

<p class="figure">
<img alt="Prex Task" src="img/task.gif" border="1"
style="width: 297px; height: 260px;"><br>
Figure 3. Prex Task
</p>

<p>
Table 1 shows kernel interfaces for task operation.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 1. Task Management Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>task_create()</td>
  <td>Create a new task</td>
</tr>
<tr>
  <td>task_terminate()</td>
  <td>Terminate a task</td>
</tr>
<tr>
  <td>task_self()</td>
  <td>Return current task ID</td>
</tr>
<tr>
  <td>task_suspend()</td>
  <td>Increment the task suspend count</td>
</tr>
<tr>
  <td>task_resume()</td>
  <td>Decrement task the task suspend count</td>
</tr>
<tr>
  <td>task_setname()</td>
  <td>Set task name</td>
</tr>
<tr>
  <td>task_setcap()</td>
  <td>Set task capabilities</td>
</tr>
<tr>
  <td>task_chkcap()</td>
  <td>Check if the task has a specific capability</td>
</tr>
</tbody>
</table>


<h3>Task Creation</h3>
<p>
The task can be created by using task_create().
New child task will have the same memory image with the parent task.
Especially text region and read-only region are physically
shared among them.
The parent task receives the new task ID of child task from task_create(), but
child task will receive 0 as task ID.
</p>
<p>
The initial task states of a created task are as follows:
</p>

<table border="1" width="80%" cellspacing="0">
<caption>Table 2. Initial task state</caption>
<tbody>
<tr>
  <th>Data Type</th>
  <th>Initial state</th>
  <th>Inherit from parent task?</th>
</tr>

<tr>
  <td>IPC Objects</td>
  <td>No IPC object</td>
  <td>No</td>
</tr>

<tr>
  <td>Threads</td>
  <td>No thread</td>
  <td>No</td>
</tr>

<tr>
  <td>Memory Space</td>
  <td>Selectable (New/Share/Copy)</td>
  <td>Selectable</td>
</tr>

<tr>
  <td>Suspend Count</td>
  <td>1</td>
  <td>No</td>
</tr>

<tr>
  <td>Exception Handler</td>
  <td>Point to parent's handler</td>
  <td>Yes</td>
</tr>

<tr>
  <td>Capabilities</td>
  <td>Inherited from parent</td>
  <td>Yes</td>
</tr>

<tr>
  <td>Task Name</td>
  <td>"*noname"</td>
  <td>No</td>
</tr>

</tbody>
</table>

<p>
If the parent task is specified as NULL for task_create(),
all child state are initialized to default.
This is used in exec() emulation.
</p>

<h3>Task Name</h3>
<p>
A kernel maintains name of each task for user mode applications
such like 'ps' command.
The task naming service (task_setname()) is provided as separated service
from task_create() because
the task name can be changed at any time by exec().
</p>

<h3>Task Suspension</h3>
<p>
All threads in the task are stopped while the task is suspended.
When the task is set to suspend state, the thread suspend count of all threads
in the task is also incremented.
A thread can start to run only when both of the thread suspend count
and the task suspend count becomes 0.
</p>

<h3>Kernel Task</h3>
<p>
A kernel task is the special task that has only an idle thread
and the interrupt threads. It does not have any user mode memory.
There exists only one kernel task which is created at boot time.
</p>

<h3>Task Capabilities</h3>
<p>
Prex supports a security framework named "task capability".
Each task will be assigned its own capabilities for various operations.
When a task tries to do a privileged operation, the
kernel, device drivers and system servers
will check the appropriate bit in the task capability.
For example, the task must have CAP_KILL capability to send an exception
to another task. Or, CAP_NICE is required to adjust the scheduling parameter
of the thread in another task.
</p>



<h2 id="thread">Thread</h2>

<h3>Major Cocepts</h3>

<p>
A thread is the unit of execution in the Prex system. A thread is a sequential
flow of control and is characterized by a thread context corresponding to the
state of the processor at any given point during the execution of the thread.
</p>

<p>
Threads contain the minimal processing state associated with a computation, e.g. a program
counter, a stack pointer, and a set of registers. A thread exists within exactly one task;
however, one task may contain many threads.
The following figure illustrates the Prex thread.
</p>

<p class="figure">
<img alt="Prex Thread" src="img/thr.gif" border="1"
style="width: 272px; height: 217px;"><br>
Figure 4. Prex Thread
</p>


<p>
Table 3 shows kernel interfaces for thread operation.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 3. Thread Management Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>thread_create()</td>
  <td>Create a new thread</td>
</tr>
<tr>
  <td>thread_terminate()</td>
  <td>Terminate a thread</td>
</tr>
<tr>
  <td>thread_load()</td>
  <td>Load specific thread context</td>
</tr>
<tr>
  <td>thread_self()</td>
  <td>Return current thread ID</td>
</tr>
<tr>
  <td>thread_yield()</td>
  <td>Release a current thread for other thread</td>
</tr>
<tr>
  <td>thread_suspend()</td>
  <td>Increment the task suspend count</td>
</tr>
<tr>
  <td>thread_resume()</td>
  <td>Decrement the task suspend count</td>
</tr>
<tr>
  <td>thread_schedparam()</td>
  <td>Change scheduling parameter</td>
</tr>

</tbody>
</table>


<h3>Thread Priority</h3>
<p>
Each thread is assigned the priority between
0 and 255. The lower number means higher priority like BSD UNIX.
It maintains 256 level run queues mapped to each priority.
The lowest priority (=255) is used only for an idle thread.
</p>
<p>
A thread has two different types of priority:
</p>
<ul>
  <li><b>Base priority:</b>
  This is a static priority which can be changed only by user mode program.
  <li><b>Current Priority:</b>
  An actual scheduling priority.
  A kernel may adjust this priority dynamically if it's needed.
</ul>
<p>
Although the base priority and the current priority are same value in most
conditions,
kernel will sometimes change the current priority to avoid
"priority inversion".
</p>

<p>
The following table shows the priority class for various thread types.
</p>

<table border="1" width="50%" cellspacing="0">
<caption>Table 4. Thread Priorities</caption>
<tbody>
<tr>
  <th>Class</th>
  <th>Priority</th>
  <th>Description</th>
</tr>
<tr>
  <td>Critical</td>
  <td>0<br>-<br>14</td>
  <td>High priority tasks</td>
</tr>
<tr>
  <td>Timer</td>
  <td>15</td>
  <td>Timer thread</td>
</tr>
<tr>
  <td>IST</td>
  <td>16<br>-<br>32</td>
  <td>Interrupt threads</td>
</tr>
<tr>
  <td>DPC</td>
  <td>33</td>
  <td>DPC thread</td>
</tr>
<tr>
  <td>Real-time</td>
  <td>34<br>-<br>127</td>
  <td>Real-time Tasks</td>
</tr>
<tr>
  <td>Normal</td>
  <td>128<br>-<br>254</td>
  <td>Normal (POSIX) tasks</td>
</tr>
<tr>
  <td>Idle</td>
  <td>255</td>
  <td>Idle thread</td>
</tr>

</tbody>
</table>






<h3>Thread State</h3>
<p>
Each thread has one of the following states.
</p>

<ul>
  <li><b>RUN</b>     :Running or ready to run</li>
  <li><b>SLEEP</b>   :Sleep for some event</li>
  <li><b>SUSPEND</b> :Suspend count is not 0</li>
  <li><b>EXIT</b>    :Terminated</li>
</ul>


<p>
The following diagram shows the state transition of a thread.
</p>

<p class="figure">
<img alt="Memory Structure" src="img/thread.gif" border="1"
style="width: 430px; height: 314px;"><br>
Figure 5. Thread States
</p>





<h3>Thread Control Block</h3>
<p>
The thread control block includes data for
owner task, scheduler, timer, IPC, exception, mutex, and context.
The following thread structure is most important definition
in the kernel codes.
</p>
<pre>
struct thread {
        struct list     link;           /* linkage on all threads */
        struct list     task_link;      /* linkage on thread list in task */
        struct queue    sched_link;     /* linkage on scheduling queue */
        task_t          task;           /* task to which I belong */
        int             state;          /* thread state */
        int             policy;         /* scheduling policy */
        int             priority;       /* current priority */
        int             basepri;        /* statical base priority */
        int             timeleft;       /* remaining ticks to run */
        u_int           time;           /* total running time */
        int             resched;        /* true if rescheduling is needed */
        int             locks;          /* schedule lock counter */
        int             suscnt;         /* suspend count */
        struct event    *slpevt;        /* event we are waiting on */
        int             slpret;         /* return value for sched_tleep */
        struct timer    timeout;        /* thread timer */
        struct timer    *periodic;      /* pointer to periodic timer */
        uint32_t        excbits;        /* bitmap of pending exceptions */
        struct list     mutexes;        /* mutexes locked by this thread */
        mutex_t         mutex_waiting;  /* mutex pointer currently waiting */
        struct queue    ipc_link;       /* linkage on IPC queue */
        void            *msgaddr;       /* kernel address of IPC message */
        size_t          msgsize;        /* size of IPC message */
        thread_t        sender;         /* thread that sends IPC message */
        thread_t        receiver;       /* thread that receives IPC message */
        object_t        sendobj;        /* IPC object sending to */
        object_t        recvobj;        /* IPC object receiving from */
        void            *kstack;        /* base address of kernel stack */
        struct context  ctx;            /* machine specific context */
};</pre>

<h3>Thread Creation</h3>

<p>
A thread can be created by thread_create().
The initial states of newly created thread are as follows:
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 5. Initial thread state</caption>
<tbody>
<tr>
  <th>Data type</th>
  <th>Initial state</th>
</tr>
<tr>
  <td>Owner Task</td>
  <td>Inherit from parent thread</td>
</tr>
<tr>
  <td>Thread state</td>
  <td>Suspended</td>
</tr>
<tr>
  <td>Suspend count</td>
  <td>Task suspend count + 1</td>
</tr>
<tr>
  <td>Scheduling policy</td>
  <td>Round Robin</td>
</tr>
<tr>
  <td>Scheduling Priority</td>
  <td>Default (= 200)</td>
</tr>
<tr>
  <td>Time quantum</td>
  <td>Default (= 50 msec)</td>
</tr>

<tr>
  <td>Processor registers</td>
  <td>Default value</td>
</tr>

</tbody>
</table>

<p>
Since new thread is initially set to the suspended state, thread_resume()
must be called to start it.
</p>

<p>
Creating a thread and loading its register state are isolated
in different routines. These two routines are used by fork(), exec(),
and pthread_create() in the POSIX emulation library.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 6. Usage of thread_create()/thread_load()</caption>
<tbody>
<tr>
  <th>Library routine</th>
  <th>thread_create()</th>
  <th>thread_load()</th>
</tr>
<tr>
  <td>fork()</td>
  <td align="center">O</td>
  <td align="center">X</td>
</tr>
<tr>
  <td>exec()</td>
  <td align="center">X</td>
  <td align="center">O</td>
</tr>
<tr>
  <td>pthread_create()</td>
  <td align="center">O</td>
  <td align="center">O</td>
</tr>
</tbody>
</table>

<p>
The address for the stack pointer is also set by thread_load().
Since the Prex kernel does not allocate any stack buffer for user mode threads,
the parent thread has responsible to allocate it.
</p>


<h3>Thread Termination</h3>
<p>
The kernel will usually release all resources owned by the terminated thread.
But, there are some complicated processes to release the resources.
For example, the priority adjustment may be required if the thread inherits its
priority.
</p>
<p>
If the thread is terminated with mutex locked, all threads waiting for
that mutex will sleep forever. So, the mutex held by the terminated thread
must be unlocked, or change its mutex owner if some thread is waiting for.

</p>
<p>
In general, there is a known issue about the thread termination.
If the termination target is the current thread, the kernel can not release
the context of the current thread because the
thread switching always requires current context.
There are the following 3 solutions for this.
</p>
<ol>
 <li>Create "clean up thread" to terminate a thread</li>
 <li>Add condition check in thread switching code</li>
 <li>Defer termination until next termination request</li>
</ol>

<p>
The Prex kernel is using #3.
</p>

<h3>Thread Suspension</h3>
<p>
Each thread can be set to the suspended state by using thread_suspend().
Although a thread can be suspended any number of times,
it does not start to run unless it is resumed by the same
number of suspend.
</p>

<h3>Kernel Thread</h3>
<p>
A kernel thread is always executed in kernel mode, and it does not have user
mode context.
The scheduling policy is set to SCHED_FIFO by default.
</p>
<p>
Currently, the following kernel threads are running in kernel mode.
</p>
<ul>
  <li>Interrupt Service Threads</li>
  <li>Timer Thread</li>
  <li>Idle Thread</li>
  <li>DPC Thread</li>
</ul>


<p>
Table 7 shows kernel interfaces to handle kernel threads.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 7. Kernel Thread Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>kthread_create()</td>
  <td>Create a new kernel thread</td>
</tr>
<tr>
  <td>kthread_terminate()</td>
  <td>Terminate a kernel thread</td>
</tr>
</tbody>
</table>

<p>
A kernel thread will be created by calling kthread_create() function.
Since we disable an interrupt during thread switching, the
interrupt is still disabled at the entry of the kernel
thread.  So, the kernel thread must enable interrupts by itself
immediately after it gets control.
</p>

<p>
The entry point for a kernel thread takes the form:
</p>

<pre>
static void
xxx_thread(void *arg)
{
        splhigh();      /* Enable interrupts */
        ...
}
</pre>

<h3>Idle Thread</h3>
<p>
An idle thread runs when no other thread is active.
It has the role of cutting down the power consumption of a system.
An idle thread has FIFO scheduling policy, and it does not
have time quantum.
The lowest scheduling priority (=255) is reserved for an idle thread.
</p>
<p>
An idle thread is just a forever-loop to call the machine
dependent routine to cut power. The following thread_idle() routine
is called at the end of the kernel initialization.
</p>
<pre>
void
thread_idle(void)
{
        for (;;) {
                machine_idle();
                sched_yield();
        }
}
</pre>
<p>
The machine_idle() routine will program the platform H/W to
the low power mode. This is typically
invoking the power saving (halt) instruction
supported by the processor.
If any interrupts are occurred in this low power mode, it must be returned
immediately from machine_idle(). Then, the idle thread will
call sched_yield() to check the re-scheduling.
</p>


<h2 id="sched">Scheduler</h2>

<h3>Scheduling Queue</h3>
<p>
The Prex scheduler is based on the algorithm known as priority based
multi level queue.

The following diagram shows each thread is linked to the
run queue for its priority.
</p>

<p class="figure">
<img alt="Run Queue" src="img/runq.gif" border="1"
style="width: 404px; height: 330px;"><br>
Figure 6. Run Queue
</p>

<h3>Scheduling Policy</h3>
<p>
There are following three types of scheduling policy.
</p>
<ul>
  <li><b>SCHED_FIFO</b>: First-in First-out
  <li><b>SCHED_RR</b>: Round Robin (SCHED_FIFO + timeslice)
  <li><b>SCHED_OTHER</b>: Not supported
</ul>
<p>
In early Prex development phase, SCHED_OTHER was implemented as a traditional
BSD scheduler. Since this scheduler changes the thread priority dynamically,
it is unpredictable and does not fit the real-time system.
Recently, SCHED_OTHER policy was dropped from Prex to
focus on real-time platform.
</p>

<p>
There are following 4 events to switch thread:
</p>

<table border="1" width="90%" cellspacing="0">
<caption>Table 8. Events to switch thread</caption>
<tbody>
<tr>
  <th>Event</th>
  <th>Condition</th>
  <th>Run queue position</th>
</tr>
<tr>
  <td><b>Block</b></td>
  <td>Thread sleep or suspend</td>
  <td>Move to the tail of runq</td>
</tr>
<tr>
  <td><b>Preemption</b></td>
  <td>Higher priority thread becomes runnable</td>
  <td>Keep the head of runq</td>
</tr>
<tr>
  <td><b>Quantum Expiration</b></td>
  <td>The thread consumes its time quantum</td>
  <td>Move to the tail of runq</td>
</tr>
<tr>
  <td><b>Yield</b></td>
  <td>The thread releases CPU by itself</td>
  <td>Move to the tail of runq</td>
</tr>

</tbody>
</table>

<p>
A thread is always preemptive even in kernel mode.
</p>


<h3>Scheduling Parameters</h3>
<p>
An application program can change the following scheduling parameters via
kernel API.
</p>
<ul>
  <li>Thread Priority</li>
  <li>Scheduling Policy</li>
</ul>

<h3>Scheduling Lock</h3>
<p>
Thread scheduling can be disabled by locking the scheduler.
This is used to synchronize thread execution to protect
accessing to the global resources.
Since an interrupt handler can run while scheduling lock state,
it does not affect to the interrupt latency.
</p>
<p>
The scheduling lock can be performed by sched_lock()/sched_unlock()
kernel functions.
</p>



<h3>Kernel Event</h3>
<p>
The kernel event consists of the queue of the sleeping threads.
</p>
<pre>
struct event {
        struct queue    sleepq;         /* queue for waiting thread */
        char            *name;          /* pointer to event name string */
};
</pre>

<p>
The kernel event must be initialized by event_init() before using it.
</p>

<pre>
static struct event     timer_event;    /* event to wakeup a timer thread */

void
timer_init(void)
{
        event_init(&amp;timer_event, "timer");
        ...
}
</pre>

<p>
Since each event has its own name,
it is easy to know which event the thread is waiting for.
The ps command can show this event name as WCHAN (wait channel).
</p>

<pre class="terminal">
[prex:/]# ps -l
  PID  PPID PRI STAT POL      TIME WCHAN       CMD
    0     0 125 R    RR          9 ipc         proc
    3     0 127 R    RR         14 ipc         exec
    2     0 126 R    RR         47 ipc         fs
    2     0 126 R    RR         72 ipc         fs
    2     0 126 R    RR         32 ipc         fs
    2     0 126 R    RR         37 ipc         fs
    1     0 253 R    RR          3 exception   init
    4     1 199 R    RR          7 exception   cmdbox
   10     4 200 R    RR          2 -           ps
[prex:/]#
</pre>


<h3>Sleep & Wakeup</h3>
<p>
If a thread must wait some events, it should enter sleep state and
release CPU resource for other thread.
The thread can sleep by calling the sched_tsleep() kernel function.
And then, to wakeup the sleeping thread, the thread can use one of the
sched_wakeup() and sched_wakeone(). These functions will insert or remove
the thread from the queue in the event object.
</p>

<p class="figure">
<img alt="Kernel Event" src="img/event.gif" border="1"
style="width: 325px; height: 281px;"><br>
Figure 7. Thread Queue
</p>

<p>
Table 9 shows kernel services for sleep/wakeup.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 9. Kernel Sleep Services</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>sched_tsleep()</td>
  <td>Sleep the current thread</td>
</tr>
<tr>
  <td>sched_wakeup()</td>
  <td>Wake up all threads sleeping on event</td>
</tr>
<tr>
  <td>sched_wakeone()</td>
  <td>Wake up one thread sleeping on event</td>
</tr>
<tr>
  <td>sched_unsleep()</td>
  <td>Cancel sleep for the specific thread</td>
</tr>

</tbody>
</table>

<p>
Note: sched_wakeone() will select the highest priority thread
among sleeping threads.
</p>

<h3>DPC</h3>
<p>
DPC (Deferred Procedure Call) is used to call the specific
function at some later time with a DPC priority. It is also
known as AST or SoftIRQ in other kernels.  DPC is typically
used by device drivers to do the low-priority jobs without
degrading real-time performance.
</p>

<p>
The following sample shows that the kernel debugger gets a control
in safer interrupt level.
</p>

<pre>
static dpc_t    kd_dpc;                 /* dpc for debugger */

/*
 * Enter kernel debugger.
 */
void
kd_enter(void)
{

        /* Call back in DPC level */
        sched_dpc(&amp;kd_dpc, &amp;kd_invoke, NULL);
}
</pre>

<p>
Each DPC routine is called by the DPC thread which works as a kernel thread.
The DPC request is inserted into the DPC queue, and that request
is processed by DPC thread in DPC priority at later time.
All interrupts are enabled and the scheduler is unlocked
when the DPC routine is called.
</p>

<p>
Since all DPC requests are maintained in single DPC queue,  request
is processed in FIFO order. When the previous DPC request is still pending and
its DPC object is used again, the kernel just over-ride the first request.
This design allows the kernel to prevent the overflow of the DPC queue, but
the device driver may need to maintain its DPC state by itself.
</p>

<p>
Prex does not support cancelling of DPC for now.
</p>

<h2 id="memory">Memory Management</h2>

<h3>Physical Page Allocator</h3>
<p>The physical page allocator provides the service for
page allocation/deallocation/reservation.
It works as a bottom layer for other memory managers.
</p>

<p class="figure">
<img alt="Memory Structure" src="img/memory.gif" border="1"
style="width: 402px; height: 278px;"><br>
Figure 8. Prex Memory Structure
</p>

<p>
The important point here is that the Prex kernel does not swap out
any pages to the disk devices. This is a significant design
policy to obtain real-time performance and system simplicity.
</p>


<p>
Table 10 shows kernel services for page allocator.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 10. Page Allocation Service</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>page_alloc()</td>
  <td>Allocate continuous pages of the specified size</td>
</tr>
<tr>
  <td>page_free()</td>
  <td>Free page block</td>
</tr>
<tr>
  <td>page_reserve()</td>
  <td>Reserve pages in specific address</td>
</tr>
</tbody>
</table>
<p>
Note: The physical address returned by page_alloc() must be translated to
the kernel address by pktokv() to access it.
</p>


<h3>Kernel Memory Allocator</h3>

<p>
The kernel provides the following services for kernel memory.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 11. Kernel Memory Allocation Service</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>kmem_alloc()</td>
  <td>Allocate memory block for kernel</td>
</tr>
<tr>
  <td>kmem_free()</td>
  <td>Free allocated memory block</td>
</tr>
<tr>
  <td>kmem_map()</td>
  <td>Map specified virtual address to the kernel address</td>
</tr>
</tbody>
</table>


<p>
The kernel memory allocator is optimized for the small
memory foot print system.
</p>
<p>
To allocate kernel memory, it is necessary to divide one page into
two or more blocks.
There are following 3 linked lists to manage used/free blocks for kernel
memory.

<ol>
  <li>All pages allocated for the kernel memory are linked.</li>
  <li>All blocks divided in the same page are linked.</li>
  <li>All free blocks of the same size are linked.</li>
</ol>
<p>
Currently, it can not handle the memory size exceeding one page.
Instead, a driver can use page_alloc() to allocate large memory.
<br>
When the kernel code illegally writes data into non-allocated memory,
the system will crash easily. The kmem modules are called from
not only kernel code but from various drivers. In order to
check the memory over run, each free block has a tag with magic ID.
</p>
<p>
The kernel maintains the array of the block headers for the free blocks.
The index of an array is decided by the size of each block.
All block has the size of the multiple of 16.
</p>
<pre>free_blks[0] = list for 16 byte block
free_blks[1] = list for 32 byte block
free_blks[2] = list for 48 byte block
     .
     .
free_blks[255] = list for 4096 byte block
</pre>
<p>
In general, only one list is used to search the free block
for a first fit algorithm.
However, the Prex kernel memory allocator is using multiple lists
corresponding to each block size.
A search is started from the list of the requested size. So,
it is not necessary to search smaller block's list wastefully.
</p>
<p>
In most of the "buddy" based memory allocators, their algorithm are
using <b>2^n</b> bytes as block size.
But, this logic will throw away much memory in case
the block size is not fit. So, this is not suitable for the
embedded systems that Prex aims to.
</p>

<h3>Virtual Memory Manager</h3>
<p>
A task owns its private virtual address space. All threads
in a same task share one memory space.
When new task is made, the address map of the parent task will be
automatically copied.
In this time, the read-only space is not copied and is shared with old map.
</p>
<p>
A kernel provides the following functions for VM:
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 12. VM Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>vm_allocate()</td>
  <td>Allocate zero-filled memory in virtual address space</td>
</tr>
<tr>
  <td>vm_free()</td>
  <td>Deallocate memory segment for the specified address</td>
</tr>
<tr>
  <td>vm_attribute()</td>
  <td>Change attribute of specified virtual address</td>
</tr>
<tr>
  <td>vm_map()</td>
  <td>Map another task's memory to current task</td>
</tr>
</tbody>
</table>

<p>
The VM allocator is using the traditional list-based algorithm.
</p>
<p>
The kernel task is a special task which has the virtual memory mapping
for kernel. All other user mode tasks will have the same kernel memory
image mapped from the kernel task. So, kernel threads can work with the
all user mode task context without switching memory map.
</p>

<p class="figure">
<img alt="Memory Mapping" src="img/memmap.gif" border="1"
style="width: 504px; height: 271px;"><br>
Figure 9. Kernel Memory Mapping
</p>

<p>
Since the Prex kernel does not do page out to an external storage,
it is guaranteed that the allocated memory is always continuing
and existing. Thereby, a kernel and drivers can be constructed
very simply.
</p>
<p>
<i>Note: "Copy-on-write" feature was supported with the Prex kernel before.
But, it was dropped to increase the real-time performance.</i>
</p>



<h2 id="ipc">IPC</h2>
<p>
The message passing model of Prex is very simple compared with other
modern microkernel. The Prex message is sent to the "object" from thread
to thread.
The "object" is similar concept that is called as "port"
in other microkernel.
</p>

<p>
Since all messages in Prex are transferred among threads, the name of
"IPC" is not appropriate.
However, "IPC" is still used as a general term of the message transfer
via the kernel, in Prex.
</p>


<h3>Object</h3>
<p>
An object represents service, state, or policies etc.
For the purpose of object manipulation, the kernel provides the following
3 basic functions:
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 13. Object Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>object_create()</td>
  <td>Create a new object</td>
</tr>
<tr>
  <td>object_lookup()</td>
  <td>Search an object in the object name space</td>
</tr>
<tr>
  <td>object_destroy()</td>
  <td>Destroy an existing object</td>
</tr>
</tbody>
</table>


<p>
The Prex task will create an object to publish its interface to other tasks.
For example, server tasks will create objects like "!proc", "!fs", "!exec" to
allow clients to access their services.
And then, client tasks will send a request message to these objects.
</p>
<p>
An actual entity of the object is stored in kernel space, and it is protected
from user mode code.
The object data is managed with the hash table by using its name string.
Usually, an object has a unique name within a system. To send a
message to the specific object, the sender must obtain the ID of the target object
by using object_lookup().
</p>
<p>
An object can be created without its name. These objects can be used as
private objects for threads in the same task.
</p>

<h3>Message</h3>
<p>
A message is a contiguous byte string which is logically copied from the sender
's address space to the receiver's address space.
</p>
<p>
The kernel provides the following interface for message operations.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 14. IPC Message Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>msg_send()</td>
  <td>Send a message</td>
</tr>
<tr>
  <td>msg_receive()</td>
  <td>Receive a message</td>
</tr>
<tr>
  <td>msg_reply()</td>
  <td>Send a reply message</td>
</tr>
</tbody>
</table>


<p>
Each IPC message must include the message header in it.
The kernel will automatically store the sender task's ID into the message header.
This mechanism ensures the receiver task can get the exact task ID
of the sender task. Therefore, receiver task can check the sender
task's capability for various secure services.
</p>

<pre>
struct msg_header {
        task_t  task;           /* id of send task */
        int     code;           /* message code */
        int     status;         /* return status */
};
</pre>

<p>
It is necessary to recognize the pre-defined message format between
sender and receiver.
</p>
<p>
Messages are sent to the specific object using msg_send().
The transmission of a message is always synchronous. This means that
the thread which sent the message is blocked until it receives
a response from another thread. msg_receive() performs reception
of a message. msg_receive() is also blocked when no message is
reached to the target object. The receiver thread must answer the
message using msg_reply() after it finishes processing.
</p>
<p>
The receiver thread can not receive another message until it
replies to the sender. In short, a thread can receive only one
message at once. Once the thread receives message, it can send
another message to different object. This mechanism allows threads
to redirect the sender's request to another thread.
</p>
<p>
A thread can receive a message from the specific object which is
created by itself or thread in same task.
If the message has not arrived, it
blocks until any message comes in. The following figure shows the IPC transmit
sequence of Prex.
</p>

<p class="figure">
<img alt="ipc queue" src="img/msg.gif" border="1"
style="width: 505px; height: 347px;"><br>
Figure 10. IPC Transmit Sequence
</p>

<h3>Message Transfer</h3>
<p>
The message is copied to task to task directly without kernel
buffering. The memory region of sent message is
automatically mapped to the receiver's memory within kernel.
This mechanism allows to reduce the number of copy time while message
transfer.
Since there is no page out of memory in Prex, we can
copy the message data via physical memory at anytime.
</p>

<p class="figure">
<img alt="Message transfer" src="img/ipcmap.gif" border="1"
style="width: 459px; height: 321px;"><br>
Figure 11. IPC message transfer
</p>

<h2 id="except">Exception Handling</h2>
<p>
A user mode task can specify its own exception handler with exception_setup().
There are two different types of exception.
</p>
<ul>
  <li><b>H/W exception</b>:
  This type of exception is caused by H/W trap &amp fault. The exception
  will be sent to the thread which caused the trap.
  If no exception handler is specified by the task, it will be
  terminated by kernel.</li>

  <li><b>S/W exception</b>:
  The user mode task can send S/W exception to another task by exception_raise().
  The exception
  will be sent to the thread that is sleeping with exception_wait().
  If no thread is waiting for the exception, the exception is sent
  to the first thread in the target task.</li>
</ul>
<p>
Kernel supports 32 types of exception.
The following pre-defined exceptions are raised by kernel itself.
</p>

<table border="1" width="80%" cellspacing="0">
<caption>Table 15. Kernel exceptions</caption>
<tbody>
<tr>
  <th>Exception</th>
  <th>Type</th>
  <th>Reason</th>
</tr>
<tr>
  <td>SIGILL</td>
  <td align="center">H/W</td>
  <td>Illegal instruction</td>
</tr>
<tr>
  <td>SIGTRAP</td>
  <td align="center">H/W</td>
  <td>Break point</td>
</tr>
<tr>
  <td>SIGFPE</td>
  <td align="center">H/W</td>
  <td>Math error</td>
</tr>
<tr>
  <td>SIGSEGV</td>
  <td align="center">H/W</td>
  <td>Invalid memory access</td>
</tr>
<tr>
  <td>SIGALRM</td>
  <td align="center">S/W</td>
  <td>Alarm event</td>
</tr>
</tbody>
</table>

<p>
POSIX emulation library will setup its own exception handler to convert
the Prex exceptions into UNIX signals. It will maintain its own signal mask.
And, it transfer control to the actual POSIX signal handler that is
defined by the user mode process.

</p>


<h2 id="int"> Interrupt Framework</h2>
<p>
Prex defines two different types of interrupt service to
optimize the response time of real-time operation.
</p>

<h3>Interrupt Service Routine (ISR)</h3>
<p>
ISR is started by an actual hardware interrupt. The associated
interrupt is disabled in ICU and CPU interrupt is enabled
while it runs. If ISR determines that its device generates
the interrupt, ISR must program the device to stop the interrupt.
Then, ISR should do minimum I/O operation and return control
as quickly as possible.
ISR will run within the context of current running thread at
interrupt time. So, only few kernel services are available within
ISR. ASSERT() macro can be used to detect the invalid
function call from ISR.
</p>

<h3>Interrupt Service Thread (IST)</h3>
<p>
IST is automatically activated if ISR returns INT_CONTINUE to kernel. It
will be called when the system enters safer condition than ISR.
Any interrupt driven I/O operation should be done in IST not ISR.
Since ISR for same IRQ may be run during IST, the shared data,
resources, and device registers must be synchronized by disabling interrupt.
IST does not have to be reentrant, since it is not interrupted
by same IST itself.
</p>


<h3>Interrupt Nesting &amp Priority</h3>
<p>
Each ISR has its logical priority level, with 0 being the lowest
priority. While one ISR is running, all lower priority interrupts
are masked off.
This interrupt nesting mechanism avoids delaying of
high priority interrupt events.
</p>



<p>
IST is executed as a normal thread dispatched by the scheduler. So,
the interrupt thread which has higher priority is executed first.
The driver writer can specify the thread priority of IST when
IST is attached to the specific interrupt line.
The important point is that even a user mode task can be performed
prior to an interrupt thread.
</p>
<p>
The following figure is the sample of the Prex interrupt processing.
</p>

<p class="figure">
<img alt="Interrupt Processing" src="img/irq.gif" border="1"
style="width: 504px; height: 347px;"><br>
Figure 12. Prex Interrupt Processing
</p>


<h3>Disabling Interrupts</h3>
<p>
splxxx() services are used to disable interrupts in
order to synchronize the access to the kernel or H/W resource.
splhigh() will raise the current interrupt level to the highest level and disable all interrupts.
In other hand, spl0() will enable all interrupts.
The caller must save the previous interrupt state and restore it with splx()
as following sample.
</p>

<pre>
int s = splhigh();              /* Raise ipl, and save previous one */
modify disk buffer cache
splx(s);                        /* Restore previous ipl */
</pre>


<h3>Interrupt Stack</h3>
<p>
If each ISR uses the kernel stack of the current running thread, the
stack area may be over-flow when continuous interrupts are occurred at
one same thread. So the kernel stack will be switched to the dedicated stack
while ISR is running.
</p>


<h2 id="timer">Timer</h2>

<p>
The kernel provides the following timer features.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 16. Kernel Timer Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>timer_sleep()</td>
  <td>Put caller thread to sleep in the specified time.</td>
</tr>
<tr>
  <td>timer_callout()</td>
  <td>Call the routine after specified time passes.</td>
</tr>
<tr>
  <td>timer_alarm()</td>
  <td>Send SIGALRM exception to the caller task when specified delay time is passed.</td>
</tr>
<tr>
  <td>timer_stop()</td>
  <td>Stop an active timer.</td>
</tr>
</tbody>
</table>

<h3>Timer Structure</h3>

<p>
The timer structure must be defined to use the kernel callout timer.
</p>

<pre>
struct timer {
        struct list     link;           /* linkage on timer chain */
        int             state;          /* timer state */
        u_long          expire;         /* expiration time, in ticks */
        u_long          interval;       /* time interval */
        void            (*func)(void *); /* function to call */
        void            *arg;           /* function argument */
        struct event    event;          /* event for this timer */
};
</pre>


<h3>Periodic Timer</h3>

<p>
The thread can become a periodic thread by calling timer_periodic() kernel
API.
The periodic thread can wait for the timer period by calling
timer_waitperiod().
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 17. Periodic Timer Interface</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>timer_periodic()</td>
  <td>Set periodic timer for the specified thread.</td>
</tr>
<tr>
  <td>timer_waitperiod()</td>
  <td>wait next period of the periodic timer.</td>
</tr>
</tbody>
</table>

<h3>Timer Thread</h3>

<p>
If the callout routines are called from the clock interrupt handler,
it will degrade real-time performance of the system because the interrupt priority
for clock is very high.
So, all callout routines in Prex are called by a timer thread 
which runs at timer priority level.
</p>
<p>
Each active timer is inserted to the kernel timer list.
The timer list is sorted by expiration time.

The timer thread is sleeping at most time.
If a clock interrupt occurs, the timer interrupt handler will check the
timer list and process the expired timer to be called by the timer thread later.
</p>


<h3>Timer Jitter</h3>

<p>
The periodic timer is designed to minimize the deviation between desired and
actual expiration.
</p>

<h2 id="device">Device I/O Services</h2>

The Prex device driver module is separated from the kernel, and this module
is linked with the kernel at the boot time.
The kernel provides only simple and minimum services to help the 
communication between applications and drivers.

<h3>Device Object</h3>
<p>
Since the Prex kernel does not have the file system in it, the kernel
provides a device object service for I/O interface.
The device object is created by the device driver to communicate to the
application. Usually, the driver creates a device object for an existing
physical device. But, it can be used to handle logical or virtual devices.
A kernel provides the following device object services for device drivers.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 18. Device Object Services</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>device_create()</td>
  <td>Create an device object</td>
</tr>
<tr>
  <td>device_destroy()</td>
  <td>Destroy existing device object</td>
</tr>
<tr>
  <td>device_lookup()</td>
  <td>Lookup specific device object</td>
</tr>
<tr>
  <td>device_control()</td>
  <td>Send devctl command to the device object</td>
</tr>
<tr>
  <td>device_broadcast()</td>
  <td>Broadcast devctl command to all device objects</td>
</tr>
<tr>
  <td>device_private()</td>
  <td>Get the private data of the device object</td>
</tr>

</tbody>
</table>


<p>
The following figure illustrates the Prex device I/O operations.
</p>

<p class="figure">
<img alt="Device I/O Processing" src="img/devobj.gif" border="1"
style="width: 498px; height: 350px;"><br>
Figure 13. Device I/O Operations
</p>


<h3>Driver Interface</h3>
<p>
The interface between kernel and drivers are defined clearly as
"Driver Kernel Interface". The kernel provides the following services
for device drivers.
</p>
<ul>
  <li>Device object service</li>
  <li>Kernel memory allocation</li>
  <li>Physical page allocation</li>
  <li>Interrupt handling service</li>
  <li>Scheduler service</li>
  <li>Timer service</li>
  <li>Debug service</li>
</ul>

<h3>Application I/O Interface</h3>
<p>
The kernel device I/O interfaces are provided to access the specific device
object which is handled by a driver. 
The Prex kernel provides the following 5 functions for applications.
</p>

<table border="1" width="70%" cellspacing="0">
<caption>Table 19. Device I/O API</caption>
<tbody>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>
<tr>
  <td>device_open()</td>
  <td>Open a device</td>
</tr>
<tr>
  <td>device_close()</td>
  <td>Close a device</td>
</tr>
<tr>
  <td>device_read()</td>
  <td>Read from a device</td>
</tr>
<tr>
  <td>device_write()</td>
  <td>Write to a device</td>
</tr>
<tr>
  <td>device_ioctl()</td>
  <td>Device I/O control</td>
</tr>

</tbody>
</table>



<h2 id="sync">Synchronous Service</h2>
<p>
The Prex kernel provides three different synchronization primitives:
</p>
<ul>
<li>Mutex</li>
<li>Condition Variable</li>
<li>Semaphore</li>
</ul>

<h3>Priority Inheritance for Mutex</h3>
<p>
The thread priority is automatically changed at one of the following conditions.
</p>
<ol>
  <li>
  When the current thread fails to lock the mutex and the mutex
  owner has lower priority than current thread, the priority
  of mutex owner is boosted to the current priority.
  If this mutex owner is waiting for another mutex, such related
  mutexes are also processed.
  </li>
  <li>
  When the current thread unlocks the mutex and its priority
  has already been boosted, kernel recomputes the current priority.
  In this case, the priority is set to the highest
  priority among the threads waiting for the mutexes locked by the
  current thread.
  </li>
  <li>
   When the priority is changed by the user request, the related (inherited)
   thread's priority is also changed.
  </li>
</ol>
<p>
There are following limitations about priority inheritance
with Prex mutex.
</p>
<ol>
  <li>
  If the priority is changed by the user request, the priority
  recomputation is done only when the new priority is higher
  than old priority. The inherited priority is reset to base
  priority when the mutex is unlocked.
  </li>
  <li>
  Even if thread is killed with mutex waiting, the related
  priority is not adjusted.
  </li>
</ol>

<h2 id="debug">Debug</h2>


<p>
There are following debugging support functions:
</p>

<ul>
  <li>printf(): Display the debug message in kernel.</li>
  <li>panic(): Dump processor registers and stop system.</li>
  <li>ASSERT(): If expression is false (zero), stop system and display information.</li>
</ul>

<p>
The output routine for printf() is initially set to the function
in HAL. However, the device driver can
override this routine by using debug_attach() service.
</p>

<h2 id="hal">Hardware Abstraction Layer</h2>

<p>
The interface to the hardware abstraction layer is strictly defined
by the Prex kernel. This interface is designed carefully to support various
different architectures with minimum code changes.
So, it is easy to port the Prex kernel to different architecture.
</p>


<p>
The following table shows the HAL class and its methods.
</p>

<table border="1" width="60%" cellspacing="0">
<caption>Table 20. HAL Interface</caption>
<tbody>

<tr>
  <th width="80">Class</th>
  <th width="100">Methods</th>
  <th>Description</th>
</tr>

<tr>
  <td rowspan="5">context</td>
  <td>set</td>
  <td>Set specific register value</td>
</tr>
<tr>
  <td>switch</td>
  <td>Switch context</td>
</tr>
<tr>
  <td>save</td>
  <td>Save user mode context</td>
</tr>
<tr>
  <td>restore</td>
  <td>Restore user mode context</td>
</tr>
<tr>
  <td>dump</td>
  <td>Dump context for debug</td>
</tr>


<tr>
  <td rowspan="5">mmu (*)</td>
  <td>map</td>
  <td>Map physical memory</td>
</tr>
<tr>
  <td>newmap</td>
  <td>Creates new page mapping</td>
</tr>
<tr>
  <td>teminate</td>
  <td>Delete all page mapping</td>
</tr>
<tr>
  <td>switch</td>
  <td>Switch to new page directory</td>
</tr>
<tr>
  <td>extract</td>
  <td>Return physical address</td>
</tr>


<tr>
  <td rowspan="3">spl</td>
  <td>splhigh</td>
  <td>Block all interrupts</td>
</tr>
<tr>
  <td>spl0</td>
  <td>Unblock all interrupts</td>
</tr>
<tr>
  <td>splx</td>
  <td>Restore the interrupt state</td>
</tr>


<tr>
  <td rowspan="4">interrupt</td>
  <td>mask</td>
  <td>Mask specific interrupt</td>
</tr>
<tr>
  <td>unmask</td>
  <td>Unmask specific interrupt</td>
</tr>
<tr>
  <td>setup</td>
  <td>Program interrupt mode (edge/level)</td>
</tr>
<tr>
  <td>init</td>
  <td>Initialize interrupt controller</td>
</tr>


<tr>
  <td>clock</td>
  <td>init</td>
  <td>Initialize clock timer device</td>
</tr>


<tr>
  <td rowspan="3">umem</td>
  <td>copyin</td>
  <td>Copy data to kernel area</td>
</tr>
<tr>
  <td>copyout</td>
  <td>Copy data to user area</td>
</tr>
<tr>
  <td>copyinstr</td>
  <td>Copy string data to kernel area</td>
</tr>


<tr>
  <td rowspan="5">machine</td>
  <td>startup</td>
  <td>Initialize basic h/w</td>
</tr>
<tr>
  <td>idle</td>
  <td>Set system to idle state</td>
</tr>
<tr>
  <td>powerdown</td>
  <td>Power down system</td>
</tr>
<tr>
  <td>abort</td>
  <td>Stop system</td>
</tr>
<tr>
  <td>bootinfo</td>
  <td>Return boot infomation</td>
</tr>


<tr>
  <td rowspan="2">diag</td>
  <td>init</td>
  <td>Initialize diagnostic port</td>
</tr>
<tr>
  <td>puts</td>
  <td>Put diag message</td>
</tr>


</tbody>
</table>

<p>
<i>*) In case of no-MMU system, MMU related routines will be
defined as no-operation routine.</i>
</p>



</div>

<div id="footer">
        <a href="http://sourceforge.net">
        <img src="http://sourceforge.net/sflogo.php?group_id=132028&amp;type=1"
        alt="SourceForge.net Logo" border="0" height="31" width="88"></a><br>
        Copyright&copy; 2005-2009 Kohsuke Ohtani
</div>

</body>
</html>
