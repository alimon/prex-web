<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>map</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-5.6.1' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<a href='../S/131.html#L301'>map</a>               301 bsp/hal/arm/arch/mmu.c 	struct mmumap *map;
<a href='../S/131.html#L304'>map</a>               304 bsp/hal/arm/arch/mmu.c 	for (map = mmumap_table; map-&gt;type != 0; map++) {
<a href='../S/131.html#L305'>map</a>               305 bsp/hal/arm/arch/mmu.c 		switch (map-&gt;type) {
<a href='../S/131.html#L316'>map</a>               316 bsp/hal/arm/arch/mmu.c 		if (mmu_map(boot_pgd, map-&gt;phys, map-&gt;virt,
<a href='../S/131.html#L317'>map</a>               317 bsp/hal/arm/arch/mmu.c 			    map-&gt;size, map_type))
<a href='../S/178.html#L262'>map</a>               262 bsp/hal/x86/arch/mmu.c 	struct mmumap *map;
<a href='../S/178.html#L265'>map</a>               265 bsp/hal/x86/arch/mmu.c 	for (map = mmumap_table; map-&gt;type != 0; map++) {
<a href='../S/178.html#L266'>map</a>               266 bsp/hal/x86/arch/mmu.c 		switch (map-&gt;type) {
<a href='../S/178.html#L277'>map</a>               277 bsp/hal/x86/arch/mmu.c 		if (mmu_map(boot_pgd, map-&gt;phys, map-&gt;virt,
<a href='../S/178.html#L278'>map</a>               278 bsp/hal/x86/arch/mmu.c 			    (size_t)map-&gt;size, map_type))
<a href='../S/318.html#L48'>map</a>                48 sys/include/task.h 	vm_map_t	map;		/* address space description */
<a href='../S/331.html#L245'>map</a>               245 sys/kern/sched.c 		vm_switch(next-&gt;task-&gt;map);
<a href='../S/334.html#L65'>map</a>                65 sys/kern/task.c 	vm_map_t map = NULL;
<a href='../S/334.html#L115'>map</a>               115 sys/kern/task.c 		map = vm_create();
<a href='../S/334.html#L118'>map</a>               118 sys/kern/task.c 		vm_reference(parent-&gt;map);
<a href='../S/334.html#L119'>map</a>               119 sys/kern/task.c 		map = parent-&gt;map;
<a href='../S/334.html#L122'>map</a>               122 sys/kern/task.c 		map = vm_dup(parent-&gt;map);
<a href='../S/334.html#L125'>map</a>               125 sys/kern/task.c 	if (map == NULL) {
<a href='../S/334.html#L134'>map</a>               134 sys/kern/task.c 	task-&gt;map = map;
<a href='../S/334.html#L205'>map</a>               205 sys/kern/task.c 	vm_terminate(task-&gt;map);
<a href='../S/334.html#L206'>map</a>               206 sys/kern/task.c 	task-&gt;map = NULL;
<a href='../S/334.html#L456'>map</a>               456 sys/kern/task.c 			info-&gt;vmsize = task-&gt;map-&gt;total;
<a href='../S/334.html#L491'>map</a>               491 sys/kern/task.c 		if ((error = vm_load(task-&gt;map, mod, &amp;stack)) != 0)
<a href='../S/343.html#L109'>map</a>               109 sys/mem/vm.c   	error = do_allocate(task-&gt;map, &amp;uaddr, size, anywhere);
<a href='../S/343.html#L119'>map</a>               119 sys/mem/vm.c   do_allocate(vm_map_t map, void **addr, size_t size, int anywhere)
<a href='../S/343.html#L127'>map</a>               127 sys/mem/vm.c   	if (map-&gt;total + size &gt;= MAXMEM)
<a href='../S/343.html#L135'>map</a>               135 sys/mem/vm.c   		if ((seg = seg_alloc(&amp;map-&gt;head, size)) == NULL)
<a href='../S/343.html#L142'>map</a>               142 sys/mem/vm.c   		if ((seg = seg_reserve(&amp;map-&gt;head, start, size)) == NULL)
<a href='../S/343.html#L153'>map</a>               153 sys/mem/vm.c   	if (mmu_map(map-&gt;pgd, pa, seg-&gt;addr, size, PG_WRITE))
<a href='../S/343.html#L161'>map</a>               161 sys/mem/vm.c   	map-&gt;total += size;
<a href='../S/343.html#L167'>map</a>               167 sys/mem/vm.c   	seg_free(&amp;map-&gt;head, seg);
<a href='../S/343.html#L200'>map</a>               200 sys/mem/vm.c   	error = do_free(task-&gt;map, addr);
<a href='../S/343.html#L207'>map</a>               207 sys/mem/vm.c   do_free(vm_map_t map, void *addr)
<a href='../S/343.html#L217'>map</a>               217 sys/mem/vm.c   	seg = seg_lookup(&amp;map-&gt;head, va, 1);
<a href='../S/343.html#L224'>map</a>               224 sys/mem/vm.c   	mmu_map(map-&gt;pgd, seg-&gt;phys, seg-&gt;addr,	seg-&gt;size, PG_UNMAP);
<a href='../S/343.html#L232'>map</a>               232 sys/mem/vm.c   	map-&gt;total -= seg-&gt;size;
<a href='../S/343.html#L233'>map</a>               233 sys/mem/vm.c   	seg_free(&amp;map-&gt;head, seg);
<a href='../S/343.html#L269'>map</a>               269 sys/mem/vm.c   	error = do_attribute(task-&gt;map, addr, attr);
<a href='../S/343.html#L276'>map</a>               276 sys/mem/vm.c   do_attribute(vm_map_t map, void *addr, int attr)
<a href='../S/343.html#L288'>map</a>               288 sys/mem/vm.c   	seg = seg_lookup(&amp;map-&gt;head, va, 1);
<a href='../S/343.html#L329'>map</a>               329 sys/mem/vm.c   		if (mmu_map(map-&gt;pgd, new_pa, seg-&gt;addr, seg-&gt;size,
<a href='../S/343.html#L343'>map</a>               343 sys/mem/vm.c   		if (mmu_map(map-&gt;pgd, seg-&gt;phys, seg-&gt;addr, seg-&gt;size,
<a href='../S/343.html#L379'>map</a>               379 sys/mem/vm.c   	error = do_map(target-&gt;map, addr, size, alloc);
<a href='../S/343.html#L386'>map</a>               386 sys/mem/vm.c   do_map(vm_map_t map, void *addr, size_t size, void **alloc)
<a href='../S/343.html#L398'>map</a>               398 sys/mem/vm.c   	if (map-&gt;total + size &gt;= MAXMEM)
<a href='../S/343.html#L414'>map</a>               414 sys/mem/vm.c   	seg = seg_lookup(&amp;map-&gt;head, start, size);
<a href='../S/343.html#L422'>map</a>               422 sys/mem/vm.c   	curmap = curtask-&gt;map;
<a href='../S/343.html#L460'>map</a>               460 sys/mem/vm.c   	struct vm_map *map;
<a href='../S/343.html#L463'>map</a>               463 sys/mem/vm.c   	if ((map = kmem_alloc(sizeof(*map))) == NULL)
<a href='../S/343.html#L466'>map</a>               466 sys/mem/vm.c   	map-&gt;refcnt = 1;
<a href='../S/343.html#L467'>map</a>               467 sys/mem/vm.c   	map-&gt;total = 0;
<a href='../S/343.html#L470'>map</a>               470 sys/mem/vm.c   	if ((map-&gt;pgd = mmu_newmap()) == NO_PGD) {
<a href='../S/343.html#L471'>map</a>               471 sys/mem/vm.c   		kmem_free(map);
<a href='../S/343.html#L474'>map</a>               474 sys/mem/vm.c   	seg_init(&amp;map-&gt;head);
<a href='../S/343.html#L475'>map</a>               475 sys/mem/vm.c   	return map;
<a href='../S/343.html#L483'>map</a>               483 sys/mem/vm.c   vm_terminate(vm_map_t map)
<a href='../S/343.html#L487'>map</a>               487 sys/mem/vm.c   	if (--map-&gt;refcnt &gt; 0)
<a href='../S/343.html#L491'>map</a>               491 sys/mem/vm.c   	seg = &amp;map-&gt;head;
<a href='../S/343.html#L495'>map</a>               495 sys/mem/vm.c   			mmu_map(map-&gt;pgd, seg-&gt;phys, seg-&gt;addr,
<a href='../S/343.html#L506'>map</a>               506 sys/mem/vm.c   		seg_delete(&amp;map-&gt;head, tmp);
<a href='../S/343.html#L507'>map</a>               507 sys/mem/vm.c   	} while (seg != &amp;map-&gt;head);
<a href='../S/343.html#L509'>map</a>               509 sys/mem/vm.c   	if (map == curtask-&gt;map) {
<a href='../S/343.html#L517'>map</a>               517 sys/mem/vm.c   	mmu_terminate(map-&gt;pgd);
<a href='../S/343.html#L518'>map</a>               518 sys/mem/vm.c   	kmem_free(map);
<a href='../S/343.html#L651'>map</a>               651 sys/mem/vm.c   vm_switch(vm_map_t map)
<a href='../S/343.html#L654'>map</a>               654 sys/mem/vm.c   	if (map != &amp;kernel_map)
<a href='../S/343.html#L655'>map</a>               655 sys/mem/vm.c   		mmu_switch(map-&gt;pgd);
<a href='../S/343.html#L662'>map</a>               662 sys/mem/vm.c   vm_reference(vm_map_t map)
<a href='../S/343.html#L665'>map</a>               665 sys/mem/vm.c   	map-&gt;refcnt++;
<a href='../S/343.html#L674'>map</a>               674 sys/mem/vm.c   vm_load(vm_map_t map, struct module *mod, void **stack)
<a href='../S/343.html#L686'>map</a>               686 sys/mem/vm.c   	vm_switch(map);
<a href='../S/343.html#L695'>map</a>               695 sys/mem/vm.c   	error = do_allocate(map, &amp;text, mod-&gt;textsz, 0);
<a href='../S/343.html#L699'>map</a>               699 sys/mem/vm.c   	error = do_attribute(map, text, PROT_READ);
<a href='../S/343.html#L707'>map</a>               707 sys/mem/vm.c   		error = do_allocate(map, &amp;data, mod-&gt;datasz + mod-&gt;bsssz, 0);
<a href='../S/343.html#L719'>map</a>               719 sys/mem/vm.c   	error = do_allocate(map, stack, DFLSTKSZ, 0);
<a href='../S/343.html#L736'>map</a>               736 sys/mem/vm.c   	return mmu_extract(curtask-&gt;map-&gt;pgd, addr, size);
<a href='../S/343.html#L745'>map</a>               745 sys/mem/vm.c   	vm_map_t map;
<a href='../S/343.html#L753'>map</a>               753 sys/mem/vm.c   	map = task-&gt;map;
<a href='../S/343.html#L754'>map</a>               754 sys/mem/vm.c   	seg = &amp;map-&gt;head;
<a href='../S/343.html#L767'>map</a>               767 sys/mem/vm.c   	} while (seg != &amp;map-&gt;head);
<a href='../S/343.html#L786'>map</a>               786 sys/mem/vm.c   	kernel_task.map = &amp;kernel_map;
<a href='../S/344.html#L102'>map</a>               102 sys/mem/vm_nommu.c 	error = do_allocate(task-&gt;map, &amp;uaddr, size, anywhere);
<a href='../S/344.html#L112'>map</a>               112 sys/mem/vm_nommu.c do_allocate(vm_map_t map, void **addr, size_t size, int anywhere)
<a href='../S/344.html#L119'>map</a>               119 sys/mem/vm_nommu.c 	if (map-&gt;total + size &gt;= MAXMEM)
<a href='../S/344.html#L127'>map</a>               127 sys/mem/vm_nommu.c 		if ((seg = seg_alloc(&amp;map-&gt;head, size)) == NULL)
<a href='../S/344.html#L135'>map</a>               135 sys/mem/vm_nommu.c 		if ((seg = seg_reserve(&amp;map-&gt;head, start, size)) == NULL)
<a href='../S/344.html#L143'>map</a>               143 sys/mem/vm_nommu.c 	map-&gt;total += size;
<a href='../S/344.html#L176'>map</a>               176 sys/mem/vm_nommu.c 	error = do_free(task-&gt;map, addr);
<a href='../S/344.html#L183'>map</a>               183 sys/mem/vm_nommu.c do_free(vm_map_t map, void *addr)
<a href='../S/344.html#L193'>map</a>               193 sys/mem/vm_nommu.c 	seg = seg_lookup(&amp;map-&gt;head, va, 1);
<a href='../S/344.html#L203'>map</a>               203 sys/mem/vm_nommu.c 	map-&gt;total -= seg-&gt;size;
<a href='../S/344.html#L204'>map</a>               204 sys/mem/vm_nommu.c 	seg_free(&amp;map-&gt;head, seg);
<a href='../S/344.html#L240'>map</a>               240 sys/mem/vm_nommu.c 	error = do_attribute(task-&gt;map, addr, attr);
<a href='../S/344.html#L247'>map</a>               247 sys/mem/vm_nommu.c do_attribute(vm_map_t map, void *addr, int attr)
<a href='../S/344.html#L258'>map</a>               258 sys/mem/vm_nommu.c 	seg = seg_lookup(&amp;map-&gt;head, va, 1);
<a href='../S/344.html#L313'>map</a>               313 sys/mem/vm_nommu.c 	error = do_map(target-&gt;map, addr, size, alloc);
<a href='../S/344.html#L320'>map</a>               320 sys/mem/vm_nommu.c do_map(vm_map_t map, void *addr, size_t size, void **alloc)
<a href='../S/344.html#L329'>map</a>               329 sys/mem/vm_nommu.c 	if (map-&gt;total + size &gt;= MAXMEM)
<a href='../S/344.html#L344'>map</a>               344 sys/mem/vm_nommu.c 	seg = seg_lookup(&amp;map-&gt;head, start, size);
<a href='../S/344.html#L352'>map</a>               352 sys/mem/vm_nommu.c 	curmap = curtask-&gt;map;
<a href='../S/344.html#L371'>map</a>               371 sys/mem/vm_nommu.c 	struct vm_map *map;
<a href='../S/344.html#L374'>map</a>               374 sys/mem/vm_nommu.c 	if ((map = kmem_alloc(sizeof(*map))) == NULL)
<a href='../S/344.html#L377'>map</a>               377 sys/mem/vm_nommu.c 	map-&gt;refcnt = 1;
<a href='../S/344.html#L378'>map</a>               378 sys/mem/vm_nommu.c 	map-&gt;total = 0;
<a href='../S/344.html#L380'>map</a>               380 sys/mem/vm_nommu.c 	seg_init(&amp;map-&gt;head);
<a href='../S/344.html#L381'>map</a>               381 sys/mem/vm_nommu.c 	return map;
<a href='../S/344.html#L389'>map</a>               389 sys/mem/vm_nommu.c vm_terminate(vm_map_t map)
<a href='../S/344.html#L393'>map</a>               393 sys/mem/vm_nommu.c 	if (--map-&gt;refcnt &gt; 0)
<a href='../S/344.html#L397'>map</a>               397 sys/mem/vm_nommu.c 	seg = &amp;map-&gt;head;
<a href='../S/344.html#L408'>map</a>               408 sys/mem/vm_nommu.c 		seg_delete(&amp;map-&gt;head, tmp);
<a href='../S/344.html#L409'>map</a>               409 sys/mem/vm_nommu.c 	} while (seg != &amp;map-&gt;head);
<a href='../S/344.html#L411'>map</a>               411 sys/mem/vm_nommu.c 	kmem_free(map);
<a href='../S/344.html#L431'>map</a>               431 sys/mem/vm_nommu.c vm_switch(vm_map_t map)
<a href='../S/344.html#L439'>map</a>               439 sys/mem/vm_nommu.c vm_reference(vm_map_t map)
<a href='../S/344.html#L442'>map</a>               442 sys/mem/vm_nommu.c 	map-&gt;refcnt++;
<a href='../S/344.html#L454'>map</a>               454 sys/mem/vm_nommu.c vm_load(vm_map_t map, struct module *mod, void **stack)
<a href='../S/344.html#L474'>map</a>               474 sys/mem/vm_nommu.c 	if ((seg = seg_create(&amp;map-&gt;head, start, size)) == NULL)
<a href='../S/344.html#L485'>map</a>               485 sys/mem/vm_nommu.c 	return do_allocate(map, stack, DFLSTKSZ, 1);
<a href='../S/344.html#L505'>map</a>               505 sys/mem/vm_nommu.c 	vm_map_t map;
<a href='../S/344.html#L513'>map</a>               513 sys/mem/vm_nommu.c 	map = task-&gt;map;
<a href='../S/344.html#L514'>map</a>               514 sys/mem/vm_nommu.c 	seg = &amp;map-&gt;head;
<a href='../S/344.html#L527'>map</a>               527 sys/mem/vm_nommu.c 	} while (seg != &amp;map-&gt;head);
<a href='../S/344.html#L537'>map</a>               537 sys/mem/vm_nommu.c 	kernel_task.map = &amp;kernel_map;
<a href='../S/874.html#L47'>map</a>                47 usr/server/exec/exec_cap.c 	const struct cap_map *map;
<a href='../S/874.html#L54'>map</a>                54 usr/server/exec/exec_cap.c 	map = &amp;cap_table[0];
<a href='../S/874.html#L55'>map</a>                55 usr/server/exec/exec_cap.c 	while (map-&gt;c_path != NULL) {
<a href='../S/874.html#L56'>map</a>                56 usr/server/exec/exec_cap.c 		if (!strncmp(path, map-&gt;c_path, PATH_MAX)) {
<a href='../S/874.html#L57'>map</a>                57 usr/server/exec/exec_cap.c 			cap = map-&gt;c_capset;
<a href='../S/874.html#L60'>map</a>                60 usr/server/exec/exec_cap.c 		map++;
<a href='../S/879.html#L164'>map</a>               164 usr/server/exec/main.c 	const struct msg_map *map;
<a href='../S/879.html#L211'>map</a>               211 usr/server/exec/main.c 		map = &amp;execmsg_map[0];
<a href='../S/879.html#L212'>map</a>               212 usr/server/exec/main.c 		while (map-&gt;code != 0) {
<a href='../S/879.html#L213'>map</a>               213 usr/server/exec/main.c 			if (map-&gt;code == msg-&gt;hdr.code) {
<a href='../S/879.html#L214'>map</a>               214 usr/server/exec/main.c 				error = (*map-&gt;func)(msg);
<a href='../S/879.html#L217'>map</a>               217 usr/server/exec/main.c 			map++;
<a href='../S/903.html#L1030'>map</a>              1030 usr/server/fs/vfs/main.c 	const struct msg_map *map;
<a href='../S/903.html#L1047'>map</a>              1047 usr/server/fs/vfs/main.c 		map = &amp;fsmsg_map[0];
<a href='../S/903.html#L1048'>map</a>              1048 usr/server/fs/vfs/main.c 		while (map-&gt;code != 0) {
<a href='../S/903.html#L1049'>map</a>              1049 usr/server/fs/vfs/main.c 			if (map-&gt;code == msg-&gt;hdr.code) {
<a href='../S/903.html#L1053'>map</a>              1053 usr/server/fs/vfs/main.c 				if (map-&gt;code == STD_BOOT) {
<a href='../S/903.html#L1057'>map</a>              1057 usr/server/fs/vfs/main.c 				if (map-&gt;code == FS_REGISTER) {
<a href='../S/903.html#L1068'>map</a>              1068 usr/server/fs/vfs/main.c 				error = (*map-&gt;func)(t, msg);
<a href='../S/903.html#L1069'>map</a>              1069 usr/server/fs/vfs/main.c 				if (map-&gt;code != FS_EXIT)
<a href='../S/903.html#L1073'>map</a>              1073 usr/server/fs/vfs/main.c 			map++;
<a href='../S/903.html#L1078'>map</a>              1078 usr/server/fs/vfs/main.c 				msg-&gt;hdr.task, map-&gt;code, error);
<a href='../S/910.html#L162'>map</a>               162 usr/server/fs/vfs/vfs_security.c 	const struct fscap_map *map;
<a href='../S/910.html#L172'>map</a>               172 usr/server/fs/vfs/vfs_security.c 	map = &amp;fscap_table[0];
<a href='../S/910.html#L173'>map</a>               173 usr/server/fs/vfs/vfs_security.c 	while (map-&gt;path != NULL) {
<a href='../S/910.html#L174'>map</a>               174 usr/server/fs/vfs/vfs_security.c 		if (!strncmp(path, map-&gt;path, map-&gt;len)) {
<a href='../S/910.html#L178'>map</a>               178 usr/server/fs/vfs/vfs_security.c 		map++;
<a href='../S/910.html#L186'>map</a>               186 usr/server/fs/vfs/vfs_security.c 			if (!capable(task, map-&gt;cap_read))
<a href='../S/910.html#L190'>map</a>               190 usr/server/fs/vfs/vfs_security.c 			if (!capable(task, map-&gt;cap_write))
<a href='../S/910.html#L196'>map</a>               196 usr/server/fs/vfs/vfs_security.c 			 path, map-&gt;cap_read, map-&gt;cap_write, map-&gt;cap_exec));
<a href='../S/910.html#L214'>map</a>               214 usr/server/fs/vfs/vfs_security.c 	const struct fscap_map *map;
<a href='../S/910.html#L220'>map</a>               220 usr/server/fs/vfs/vfs_security.c 	map = &amp;fscap_table[0];
<a href='../S/910.html#L221'>map</a>               221 usr/server/fs/vfs/vfs_security.c 	while (map-&gt;path != NULL) {
<a href='../S/910.html#L222'>map</a>               222 usr/server/fs/vfs/vfs_security.c 		if (!strncmp(path, map-&gt;path, map-&gt;len)) {
<a href='../S/910.html#L226'>map</a>               226 usr/server/fs/vfs/vfs_security.c 		map++;
<a href='../S/910.html#L233'>map</a>               233 usr/server/fs/vfs/vfs_security.c 	if ((found == 1) &amp;&amp; (map-&gt;cap_exec == ACC_OK)) {
<a href='../S/916.html#L396'>map</a>               396 usr/server/pow/pow.c 	const struct msg_map *map;
<a href='../S/916.html#L455'>map</a>               455 usr/server/pow/pow.c 			map = NULL;
<a href='../S/916.html#L459'>map</a>               459 usr/server/pow/pow.c 			map = &amp;powermsg_map[0];
<a href='../S/916.html#L460'>map</a>               460 usr/server/pow/pow.c 			while (map-&gt;code != 0) {
<a href='../S/916.html#L461'>map</a>               461 usr/server/pow/pow.c 				if (map-&gt;code == msg.hdr.code) {
<a href='../S/916.html#L462'>map</a>               462 usr/server/pow/pow.c 					error = (*map-&gt;func)(&amp;msg);
<a href='../S/916.html#L465'>map</a>               465 usr/server/pow/pow.c 				map++;
<a href='../S/916.html#L474'>map</a>               474 usr/server/pow/pow.c 		if (map != NULL &amp;&amp; error != 0)
<a href='../S/916.html#L476'>map</a>               476 usr/server/pow/pow.c 				 map-&gt;code, error));
<a href='../S/917.html#L525'>map</a>               525 usr/server/proc/main.c 	const struct msg_map *map;
<a href='../S/917.html#L559'>map</a>               559 usr/server/proc/main.c 		map = &amp;procmsg_map[0];
<a href='../S/917.html#L560'>map</a>               560 usr/server/proc/main.c 		while (map-&gt;code != 0) {
<a href='../S/917.html#L561'>map</a>               561 usr/server/proc/main.c 			if (map-&gt;code == msg.hdr.code) {
<a href='../S/917.html#L565'>map</a>               565 usr/server/proc/main.c 				error = (*map-&gt;func)(&amp;msg);
<a href='../S/917.html#L568'>map</a>               568 usr/server/proc/main.c 			map++;
<a href='../S/917.html#L578'>map</a>               578 usr/server/proc/main.c 				 map-&gt;code, error));
</pre>
</body>
</html>
